/*****************************************************************************
 *
 * NXP Confidential Proprietary
 *
 * Copyright (c) 2017 NXP Semiconductor;
 * All Rights Reserved
 *
 *****************************************************************************
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

#include "apu_gen.h"
#include "warp.h"
#include "transform_lut.h"
#include "opencv2/imgcodecs.hpp"
#include "time.h"


  #include "apex.h"


int main(int, char **)
{
    // This is needed only for the Target Compiler
    // HW and resources init


/**********************************************************************
    The APU_CALL is placeholder for calling the graph.
    The definition of APU_CALL is generated by graph tool to perform
    all the manipulations with created process.
    The user can change this code using other methods for process manipulation
    generated by graph tool.
**********************************************************************/
    vsdk::UMat image = cv::imread("1.jpg",
    CV_LOAD_IMAGE_COLOR).getUMat(cv::ACCESS_RW);
    vsdk::UMat out = vsdk::UMat(720,
    1280,VSDK_CV_8UC3);


    Transform_LUT tf = Transform_LUT();
    Warp warp = Warp(0);

    clock_t start = clock();

    warp.Warp_BirdEye(image, out, tf);

    clock_t end = clock();
    std::cout<<end-start<<std::endl;

    cv::imwrite("2.png", (cv::UMat)out);
    return 0;
}

/*****************************************************************************
 *
 * NXP Confidential Proprietary
 *
 * Copyright (c) 2017 NXP Semiconductor;
 * All Rights Reserved
 *
 *****************************************************************************
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

#include "apu_gen.h"
#include <apexcv_pro_remap.h>
#include <apexcv_pro_affine.h>

#ifdef APEX2_EMULATE
  #include "apu_lib.hpp"
  #include "apu_extras.hpp"
  #include "acf_lib.hpp"
  using namespace APEX2;
#else
  #include "apex.h"
#endif
using namespace std;
  void perspective_to_maps(const cv::Mat &perspective_mat, const cv::Size img_size,
                           cv::Mat &map1, cv::Mat &map2) {
      // invert the matrix because the transformation maps must be
      // bird's view -> original
      cv::Mat inv_perspective(perspective_mat.inv());
      inv_perspective.convertTo(inv_perspective, CV_32FC1);

      // create XY 2D array
      // (((0, 0), (1, 0), (2, 0), ...),
      //  ((0, 1), (1, 1), (2, 1), ...),
      // ...)
      cv::Mat xy(img_size, CV_32FC2);
      float *pxy = (float *) xy.data;
      for (int y = 0; y < img_size.height; y++)
          for (int x = 0; x < img_size.width; x++) {
              *pxy++ = x;
              *pxy++ = y;
          }

      // perspective transformation of the points
      cv::Mat xy_transformed;
      cv::perspectiveTransform(xy, xy_transformed, inv_perspective);

      //Prevent errors when float32 to int16
      float *pmytest = (float *) xy_transformed.data;
      for (int y = 0; y < xy_transformed.rows; y++)
          for (int x = 0; x < xy_transformed.cols; x++) {
              if (abs(*pmytest) > 5000) *pmytest = 5000.00;
              pmytest++;
              if (abs(*pmytest) > 5000) *pmytest = 5000.00;
              pmytest++;
          }

      // split x/y to extra maps
      assert(xy_transformed.channels() == 2);
      cv::Mat maps[2]; // map_x, map_y
      cv::split(xy_transformed, maps);

      // remap() with integer maps is faster
      cv::convertMaps(maps[0], maps[1], map1, map2, CV_16SC2);

  }

int main(int, char **)
{
    // This is needed only for the Target Compiler
    // HW and resources init
    ACF_Init();

/**********************************************************************
    The APU_CALL is placeholder for calling the graph.
    The definition of APU_CALL is generated by graph tool to perform
    all the manipulations with created process.
    The user can change this code using other methods for process manipulation
    generated by graph tool.
**********************************************************************/
    const int clSrcWidth = 1280;
      const int clSrcHeight = 720;

      // Allocate the input and output buffers
      vsdk::UMat lInput0(clSrcHeight, clSrcWidth, VSDK_CV_8UC1);
      vsdk::UMat lOutput0(clSrcHeight, clSrcWidth, VSDK_CV_8UC1);

      lInput0 = cv::imread("1.jpg",0).getUMat(cv::ACCESS_RW);

      cv::Point2f perspectiveSrc[] = {cv::Point2f(565, 470), cv::Point2f(721, 470), cv::Point2f(277, 698),
                                      cv::Point2f(1142, 698)};

      cv::Mat perspectiveMatrix;
      cv::Point2f perspectiveDst[] = {cv::Point2f(300, 0), cv::Point2f(980, 0), cv::Point2f(300, 720), cv::Point2f(980, 720)};
      perspectiveMatrix = getPerspectiveTransform(perspectiveSrc, perspectiveDst);
      vsdk::UMat tf = perspectiveMatrix.getUMat(cv::ACCESS_READ);
      cv::Size size = ((cv::Mat)lInput0.getMat(cv::ACCESS_READ)).size();
cout<<"point 1"<<endl;
      cv::Mat map1, map2;

      perspective_to_maps(perspectiveMatrix, size, map1, map2);
      cout<<"point 2"<<endl;
      float lTransform[clSrcWidth*clSrcHeight*2];
      int index = 0;
      for(int i= 0 ; i<clSrcWidth;i++) {
    	  for(int j = 0; j<clSrcHeight;j++) {
    		  cout<<"point 3"<<endl;
    		  cout<< map1.at<int>(1,1);
    		  cout<<"point 4"<<endl;
    		  index++;
		lTransform[index] = map2.at<float>(i,j);
		index++;
		std::cout<<index<<" ";
    	  }
      }


//      float lTransform[clSrcWidth*clSrcHeight*2];
//      // Create an horizontal mirroring mapping
//      for (int x = 0; x < clSrcWidth; x++)
//      {
//        for (int y = 0; y < clSrcHeight; y++)
//        {
//          int lOffset = 2 * ((y*clSrcWidth) + x);
//          lTransform[lOffset + 0] = clSrcWidth-1-x;//x
//          lTransform[lOffset + 1] = y;//y
//        }
//      }
//
//      // Control output
//      printf("Data on: \n");
//      printf("   Input             (%dx%d bytes) at %p\n", clSrcWidth, clSrcHeight, lInput0.u->handle);
//      printf("   Output            (%dx%d words) at %p\n", clSrcWidth, clSrcHeight, lOutput0.u->handle);
//
//
//
      int lRetVal = 0;
//
//      // Create a new add process for the Apex core.
      apexcv::Remap myRemap;

      // Initialize the process, this is the mandatory first call to apexcv object
      lRetVal |= myRemap.Initialize(lTransform, clSrcWidth, clSrcHeight, clSrcWidth, apexcv::INTER_TYPE::INTER_LINEAR, apexcv::BORDER_TYPE::BORDER_CONSTANT, 0);
      if (lRetVal)
      {
        printf("Error on Initialize: %d \n", lRetVal);
        return lRetVal;
      }
      printf("Initialize Done \n");

      // Compute the results, the output buffer is updated after Process executes
      lRetVal |= myRemap.Process(lInput0, lOutput0);
      if (lRetVal)
      {
        printf("Error on Process: %d \n", lRetVal);
        return lRetVal;
      }
      printf("Process Done \n");

      cv::imwrite("remap_out.png", (cv::UMat)lOutput0);



      printf("Success....END [pass]\n");

      return 0;
}


